#  This file is part of the NssMPClib project.
#  Copyright (c) 2024 XDU NSS lab,
#  Licensed under the MIT license. See LICENSE in the project root for license information.
import os
import random
import re
from typing import Iterator, List, Tuple, Union

import torch

from NssMPC import RingTensor
from NssMPC.config import param_path, base_path, DEBUG_LEVEL, data_type, DEVICE, DTYPE
from NssMPC.infra.mpc.param_provider.parameter import Parameter
from NssMPC.infra.mpc.param_provider.param_provider import FixedShapeProvider
from NssMPC.infra.mpc.party import Party, PartyCtx
from NssMPC.infra.tensor import RingTensor
from NssMPC.infra.utils.cuda_utils import cuda_matmul
from NssMPC.primitives.homomorphic_encryption.paillier import Paillier
from NssMPC.primitives.secret_sharing import AdditiveSecretSharing


class AssMulTriples(Parameter):
    """
    This is a parameter class for ASS multiplication triples, which allows the generation and saving of ASS multiplication triples.
    """

    def __init__(self):
        """
        Initializes the a, b, and c of the multiplicative triple and sets the size of the elements in the triple to 0.
        """
        self.a = None
        self.b = None
        self.c = None
        self.size = 0

    def __iter__(self) -> Iterator:
        """
        Iterator support.

        Allows the BooleanTriples instance to be iterated over, returning each element of the triple.

        Returns:
            Returns an iterator for boolean triples.
        """
        return iter((self.a, self.b, self.c))

    # def set_name(self, name):
    #     self.name = name
    #
    # def set_party(self, party) -> None:
    #     """
    #     Set party properties for parameters a, b, c.
    #
    #     :param party: the party to generate triples
    #     :type party: Party
    #     """
    #     self.a.party = party
    #     self.b.party = party
    #     self.c.party = party

    #
    def set_triples(self, a: RingTensor, b: RingTensor, c: RingTensor) -> None:
        """
        Set attributes a, b, c of the class.

        Args:
            a: The first element of the triple.
            b: The second element of the triple.
            c: The third element of the triple.
        """
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def gen(num_of_triples: int, num_of_party: int = 2, type_of_generation: str = 'TTP',
            party=None) -> Union[List['AssMulTriples'], 'AssMulTriples']:
        """
        Generate a specified number of Boolean triples according to different generation methods.

        Call the corresponding function based on the value of type_of_generation to generate Boolean triples:
            * gen_triples_by_homomorphic_encryption : Generate triples based on homomorphic encryption.
            * gen_triples_by_ttp : Generates triples based on trusted third parties.

        Args:
            num_of_triples: Number of triples.
            num_of_party: Number of parties.
            type_of_generation: Generation type. (TTP: generated by trusted third party, HE: generated by homomorphic encryption).
            party (Party, optional): Party if HE.

        Returns:
            Generated triples.

        Examples:
            >>> triples = AssMulTriples.gen(100)
        """
        if type_of_generation == 'HE':
            return gen_triples_by_homomorphic_encryption(num_of_triples, party)
        elif type_of_generation == 'TTP':
            return gen_triples_by_ttp(num_of_triples, num_of_party, share_type='normal')

    @classmethod
    def gen_and_save(cls, num: int, num_of_party: int = 2, saved_name: str = None, saved_path: str = None,
                     type_of_generation: str = 'TTP', party=None) -> None:
        """
        Generates a Boolean triple and saves it to the specified path.

        First asserts that type_of_generation is a valid value ('HE' or 'TTP'), and then generates the required
        Boolean triple. If saved_path is not specified, the default path is used. If the path does not exist,
        create it.
            * For triples generated by 'TTP', loop through each participant and save the file.
            * For triples generated by 'HE', a new file name is created for saving based on the ID of the current participant.

        Args:
            num: Number of triples.
            num_of_party: Number of parties.
            saved_name: Optional file name to save.
            saved_path: Saved path for the generated params.
            type_of_generation: Generation type. (TTP: generated by trusted third party, HE: generated by homomorphic encryption).
            party (Party, optional): Party if HE.

        Examples:
            >>> AssMulTriples.gen_and_save(100)
        """
        triples = cls.gen(num, num_of_party, type_of_generation, party)
        if saved_path is None:
            file_path = f"{param_path}AssMulTriples/"
        else:
            file_path = saved_path
        if not os.path.exists(file_path):
            os.makedirs(file_path)

        if saved_name is None:
            saved_name = 'AssMulTriples'

        if type_of_generation == 'TTP':
            for i in range(num_of_party):
                file_name = f"{saved_name}_{i}.pth"
                triples[i].save(file_path=file_path, name=file_name)

        # todo HE部分没有做适配
        elif type_of_generation == 'HE':
            file_names = os.listdir(file_path)
            max_ptr = 0
            for fname in file_names:
                match = re.search(rf"AssMulTriples{party.party_id}+_(\d+)\.pth", fname)
                if match:
                    max_ptr = max(max_ptr, int(match.group(1)))
            file_name = f"AssMulTriples_{party.party_id}_{max_ptr + 1}.pth"
            triples.save(file_path=file_path, name=file_name)


class MatmulTriples(AssMulTriples):
    @staticmethod
    def gen(num_of_triples: int, x_shape: Tuple = None, y_shape: Tuple = None, num_of_party: int = 2):
        """
        Generate multiplicative Beaver triples.

        Generate matrix multiplication triples using trusted third parties.

        Args:
            num_of_triples: Number of triples.
            x_shape: The shape of the matrix x.
            y_shape: The shape of the matrix y.
            num_of_party: Number of parties.

        Returns:
            The matrix multiplication Beaver triples.

        Examples:
            >>> triples = MatmulTriples.gen(10, (2, 3), (3, 2))
        """
        return gen_matrix_triples_by_ttp(num_of_triples, x_shape, y_shape, num_of_party)

    @classmethod
    def gen_and_save(cls, num_of_triples, x_shape=None, y_shape=None, num_of_party=2):
        """
        Generate and save multiplicative Beaver triples.

        Args:
            num_of_triples (int): The number of triples.
            x_shape (tuple, optional): The shape of the matrix x.
            y_shape (tuple, optional): The shape of the matrix y.
            num_of_party (int): The number of parties.

        Examples:
            >>> MatmulTriples.gen_and_save(10, (2, 3), (3, 2))
        """
        triples = cls.gen(num_of_triples, x_shape, y_shape, num_of_party)
        for party_id in range(num_of_party):
            file_path = base_path + f"/aux_parameters/BeaverTriples/{num_of_party}party/Matrix"
            file_name = f"MatrixBeaverTriples_{party_id}_{list(x_shape)}_{list(y_shape)}.pth"
            triples[party_id].save_by_name(file_name, file_path)

    @classmethod
    def load_provider(cls, party):
        """
        Load the provider for the party.

        Args:
            party (Party): The party instance.

        Returns:
            MatrixBeaverProvider: The loaded provider.

        Examples:
            >>> provider = MatmulTriples.load_provider(party)
        """
        provider=MatrixBeaverProvider(party=party)
        party.append_provider(provider)
        return provider
        # TODO check


def gen_triples_by_ttp(num_of_triples: int, num_of_party: int, share_type: str = 'normal'):
    """
    Generate the multiplication Beaver triple by trusted third party.

    First, two random RingTensor, a and b, are randomly generated. Then c = a * b is calculated. Then
    Select a different secret share method for distribution according to the value of share_type:
        * Normal Sharing: Share using ArithmeticSecretSharing, where each participant receives part of the data.
        * Replication Sharing: Share using ReplicatedSecretSharing, where all participants receive the same data.

    Each participant generates an AssMulTriples object, storing the shared a, b, c, and size information.

    Args:
        num_of_triples: Number of triples.
        num_of_party: Number of parties.
        share_type: Share type, normal or replicate.

    Returns:
        The multiplication triple.

    Examples:
        >>> triples = gen_triples_by_ttp(100, 2)
    """

    a = RingTensor.random([num_of_triples])
    b = RingTensor.random([num_of_triples])
    c = a * b
    a_list = AdditiveSecretSharing.share(a, num_of_party)
    b_list = AdditiveSecretSharing.share(b, num_of_party)
    c_list = AdditiveSecretSharing.share(c, num_of_party)
    triples = []
    for i in range(num_of_party):
        triples.append(AssMulTriples())
        triples[i].a = a_list[i].to('cpu')
        triples[i].b = b_list[i].to('cpu')
        triples[i].c = c_list[i].to('cpu')
        triples[i].size = num_of_triples
    return triples


def gen_triples_by_homomorphic_encryption(num_of_triples: int, party) -> AssMulTriples:
    """
    Generate the multiplication Beaver triple by homomorphic encryption.

    First, two arrays a and b are randomly generated.
        If the current participant's party_id is 0:
                First, the key of Paillier homomorphic encryption is generated to encrypt a and b, and then the encrypted
                value is sent to other participants, and the data from other participants is received, and the value of c is
                decrypted.

        If the current participant's party_id is 1:
            The random value r is first generated to compute the partial value of c. After receiving the message
            from Party 0, r is encrypted using homomorphic encryption, and a new encrypted value d is calculated
            based on the received data, and then sent back. Each participant's values are converted to tensors on
            the CPU device and stored in the triples.

    Args:
        num_of_triples: Number of triples.
        party (Party): The party to generate triples.

    Returns:
        An AssMulTriples that includes a, b, and c.

    Examples:
        >>> triples = gen_triples_by_homomorphic_encryption(100, party)
    """
    a = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
    b = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
    c = []

    if party.party_id == 0:
        paillier = Paillier()
        paillier.gen_keys()

        encrypted_a = paillier.encrypt(a)
        encrypted_b = paillier.encrypt(b)

        party.send([encrypted_a, encrypted_b, paillier.public_key])

        d = party.recv()
        decrypted_d = paillier.decrypt(d)
        c = [decrypted_d[i] + a[i] * b[i] for i in range(num_of_triples)]

    elif party.party_id == 1:

        r = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
        c = [a[i] * b[i] - r[i] for i in range(num_of_triples)]

        messages = party.recv()

        encrypted_r = Paillier.encrypt_with_key(r, messages[2])
        d = [messages[0][i] ** b[i] * messages[1][i] ** a[i] * encrypted_r[i] for i in range(num_of_triples)]

        party.send(d)

    triples = AssMulTriples()
    triples.a = AdditiveSecretSharing(RingTensor(a).to('cpu'))
    triples.b = AdditiveSecretSharing(RingTensor(b).to('cpu'))
    triples.c = AdditiveSecretSharing(RingTensor(c).to('cpu'))
    triples.size = num_of_triples

    return triples


def gen_matrix_triples_by_ttp(num_of_param: int, x_shape: Tuple, y_shape: Tuple, num_of_party: int = 2):
    """
    Generate the matrix multiplication Beaver triple by trusted third party.

    First, num_of_param is added as the first dimension to the shape of x and y to generate an independent matrix
    for each triplet. The RingTensor.random method is then used to generate
    two random matrices a and b.
        * If the matrix is on the CPU: Calculate the value of c directly using the matrix multiplication operator @.
        * If the matrix is on the GPU: Call cuda_matmul to perform the calculation and then convert the result to a ring tensor.

    The function is divided into two cases based on the number of parties involved: 2 and 3 parties:
        * Two-party sharing: Use ArithmeticSecretSharing for normal secret sharing. The resulting shared results are converted to CPU format and stored in the MatmulTriples object.
        * Three-party sharing: Uses ReplicatedSecretSharing for replication sharing, which applies to three-party computing scenarios. The results are also converted to CPU format and stored in the RssMatmulTriples object.

    Args:
        num_of_param: Number of parameters.
        x_shape: The shape of the matrix x.
        y_shape: The shape of the matrix y.
        num_of_party: Number of parties.

    Returns:
        The matrix multiplication Beaver triples.

    Examples:
        >>> triples = gen_matrix_triples_by_ttp(10, (2, 3), (3, 2))
    """
    x_shape = [num_of_param] + list(x_shape)
    y_shape = [num_of_param] + list(y_shape)
    a = RingTensor.random(x_shape)
    b = RingTensor.random(y_shape)
    if a.device == 'cpu':
        c = a @ b
    else:
        c = cuda_matmul(a.tensor, b.tensor)
        c = RingTensor.convert_to_ring(c)

    a_list = AdditiveSecretSharing.share(a, num_of_party)
    b_list = AdditiveSecretSharing.share(b, num_of_party)
    c_list = AdditiveSecretSharing.share(c, num_of_party)
    triples = []
    for i in range(num_of_party):
        triples.append(MatmulTriples())
        triples[i].a = a_list[i].to('cpu')
        triples[i].b = b_list[i].to('cpu')
        triples[i].c = c_list[i].to('cpu')

    return triples


def beaver_mul(x: AdditiveSecretSharing, y: AdditiveSecretSharing, party: Party = None) -> AdditiveSecretSharing:
    """
    Perform secure element-wise multiplication using the Beaver Triples protocol.

    This function utilizes pre-computed multiplication triples ([a], [b], [c]) (where c = a * b)
    to securely compute x * y without revealing the underlying values.
    It supports automatic broadcasting (expanding the smaller tensor to match the larger one).

    Args:
        x: The first operand (multiplicand).
        y: The second operand (multiplier).
        party: The party instance managing the communication. Defaults to None.

    Returns:
        The shared result of the element-wise multiplication.

    Examples:
        >>> res = beaver_mul(x, y)
    """
    if party is None:
        party = PartyCtx.get()
    a, b, c = party.get_param(AssMulTriples, x.numel())  # TODO: need fix, get triples based on x.shape and y.shape
    a.dtype = b.dtype = c.dtype = x.dtype
    e = x - a
    f = y - b

    e_and_f = x.__class__.cat([e.flatten(), f.flatten()], dim=0)
    common_e_f = e_and_f.restore()
    common_e = common_e_f[:x.numel()].reshape(x.shape)
    common_f = common_e_f[x.numel():].reshape(y.shape)

    res1 = RingTensor.mul(common_e, common_f) * party.party_id
    res2 = RingTensor.mul(a.item, common_f)
    res3 = RingTensor.mul(common_e, b.item)
    res = res1 + res2 + res3 + c.item

    res = x.__class__(res)
    return res


def secure_matmul(x: AdditiveSecretSharing, y: AdditiveSecretSharing,
                  party: Party = None) -> AdditiveSecretSharing:
    """
    Perform secure matrix multiplication using Beaver Triples.

    This function computes the matrix product of two secret-shared tensors.
    Unlike element-wise multiplication, this requires Matrix Beaver Triples to handle the row-column dot products securely.

    Note:
        Input shapes must satisfy matrix multiplication rules:
        If x is shape (M, K) and y is shape (K, N), the result will be (M, N).

    Args:
        x: The left input matrix.
        y: The right input matrix.
        party: The party instance managing the communication. Defaults to None.

    Returns:
        The shared result of the matrix multiplication.

    Examples:
        >>> res = secure_matmul(x, y)
    """
    if party is None:
        party = PartyCtx.get()
    a_matrix, b_matrix, c_matrix = party.get_param(MatmulTriples, x.shape, y.shape)

    e = x - a_matrix
    f = y - b_matrix

    e_and_f = x.__class__.cat([e.flatten(), f.flatten()], dim=0)
    common_e_f = e_and_f.restore()
    common_e = common_e_f[:x.numel()].reshape(x.shape)
    common_f = common_e_f[x.numel():].reshape(y.shape)

    res1 = RingTensor.matmul(common_e, common_f)
    res2 = RingTensor.matmul(common_e, b_matrix.item)
    res3 = RingTensor.matmul(a_matrix.item, common_f)

    res = res1 * party.party_id + res2 + res3 + c_matrix.item

    res = x.__class__(res)

    return res


class MatrixBeaverProvider(FixedShapeProvider):
    """
    Matrix Beaver Provider for ArithmeticSecretSharing.
    """

    def __init__(self, party=None, saved_name=None, param_tag=None, root_path=None):
        """
        Initialize the MatrixBeaverProvider class.

        Args:
            party (Party, optional): Participant.
            saved_name (str, optional): Optional file name to save.
            param_tag (str, optional): A label used to identify parameters.
            root_path (str, optional): The root path of the parameter file.
        """
        super().__init__(MatmulTriples, party, saved_name, param_tag, root_path)

    def load_param(self, x_shape=None, y_shape=None, num_of_party=2):
        """
        This method is responsible for loading the parameters for matrix.

        First, generate file names to load the corresponding matrix triples. Then try loading the saved triples from a specified path.

        Args:
            x_shape (tuple, optional): The shape of the matrix x.
            y_shape (tuple, optional): The shape of the matrix y.
            num_of_party (int): The number of party.

        Raises:
            Exception: If the file cannot be found.

        Examples:
            >>> provider.load_param((2, 3), (3, 2))
        """
        file_name = f"MatrixBeaverTriples_{self.party.party_id}_{list(x_shape)}_{list(y_shape)}.pth"
        file_path = param_path + f"BeaverTriples/{num_of_party}party/Matrix"
        try:
            self.param = MatmulTriples.load(file_path + file_name)
        except FileNotFoundError:
            raise Exception("Need generate matrix triples in this shape first!")

    def get_parameters(self, x_shape=None, y_shape=None):
        """
        Get the current matrix's parameters from the parameters.

        If DEBUG_LEVEL is 2:
            First check if there are already parameters for the shape. If not, generate a new parameter. The Beaver Triples are then created, creating tensors a and b with all 1, and calculating the shape of c based on the shape. Wrap these tensors with RingTensor to create the corresponding ASS object. Store these objects in the self.param dictionary.

        If DEBUG_LEVEL is not 2:
            Pop Beaver Triples from the argument list and update the pointer matrix_ptr

        Args:
            x_shape (tuple, optional): The shape of the matrix x.
            y_shape (tuple, optional): The shape of the matrix y.

        Returns:
            list: Beaver Triples.

        Examples:
            >>> params = provider.get_parameters((2, 3), (3, 2))
        """
        if DEBUG_LEVEL == 2:
            if f"{list(x_shape)}_{list(y_shape)}" not in self.param.keys():
                a = torch.ones(x_shape, dtype=data_type, device=DEVICE)
                b = torch.ones(y_shape, dtype=data_type, device=DEVICE)
                if len(x_shape) == 1 and len(y_shape) == 1:
                    x_shape = (1, x_shape[0])
                    y_shape = (y_shape[0], 1)
                elif len(x_shape) == 1:
                    x_shape = (1, x_shape[0])
                elif len(y_shape) == 1:
                    y_shape = (1, y_shape[0])
                assert x_shape[-1] == y_shape[-2]
                c_shape = torch.broadcast_shapes(x_shape[:-2], y_shape[:-2]) + (x_shape[-2], y_shape[-1])
                c = torch.ones(c_shape, dtype=data_type, device=DEVICE) * x_shape[-1] * 2  # todo: c != a @ b也对?

                a_tensor = RingTensor(a, dtype=DTYPE).to(DEVICE)
                b_tensor = RingTensor(b, dtype=DTYPE).to(DEVICE)
                c_tensor = RingTensor(c, dtype=DTYPE).to(DEVICE)

                from NssMPC.primitives.secret_sharing import \
                    AdditiveSecretSharing
                a = AdditiveSecretSharing(a_tensor)
                b = AdditiveSecretSharing(b_tensor)
                c = AdditiveSecretSharing(c_tensor)

                self.param[f"{list(x_shape)}_{list(y_shape)}"] = MatmulTriples()
                self.param[f"{list(x_shape)}_{list(y_shape)}"].set_triples(a, b, c)
            return self.param[f"{list(x_shape)}_{list(y_shape)}"]
        else:
            mat_beaver = self.param[self.matrix_ptr].pop()
            self.matrix_ptr = (self.matrix_ptr + 1) % self.matrix_ptr_max
            return mat_beaver.to(DEVICE)
