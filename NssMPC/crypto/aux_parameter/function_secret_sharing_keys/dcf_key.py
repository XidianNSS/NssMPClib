"""

This document defines the DCFKey class for function secret sharing in distributed comparison functions (DCF)
in the context of secure multi-party computation. The keys generated by this class are used to
securely evaluate DCF between parties.
The implementation is based on the work of E. Boyle e.t.c. Function Secret Sharing for Mixed-Mode and Fixed-Point Secure Computation.2021
For reference, see the `paper <https://link.springer.com/chapter/10.1007/978-3-030-77886-6_30>`_.
"""

#  This file is part of the NssMPClib project.
#  Copyright (c) 2024 XDU NSS lab,
#  Licensed under the MIT license. See LICENSE in the project root for license information.

import torch

from NssMPC.common.random import PRG
from NssMPC.common.utils import convert_tensor
from NssMPC.config import data_type, DEVICE, LAMBDA, HALF_RING, PRG_TYPE, BIT_LEN
from NssMPC.crypto.aux_parameter import Parameter
from NssMPC.crypto.aux_parameter.function_secret_sharing_keys.cw import CW, CWList


class DCFKey(Parameter):
    """
    The function secret sharing key for distributed comparison function(DCF).

    This class implements the secret sharing keys required for function secret sharing(FSS) in
    distributed comparison functions (DCF). It includes methods for generating
    and managing the correction words and other key parameters used in the DCF protocol.

    ATTRIBUTES:
        * **s** (*torch.Tensor*): A binary string (Î» bits) generated by the PRG for the root node.
        * **cw_list** (:class:`CWList <NssMPC.crypto.aux_parameter.function_secret_sharing_keys.cw.CWList>`): The list of correction words used in the comparison function.
        * **ex_cw_dcf** (*torch.Tensor*): The extra check word used for DCF calculation.
        * **size** (*int*): The size of the key (default is 0).
    """

    def __init__(self):
        """
        Initialize the DCFKey object.

        This method initializes the seed `s` to *None*, the list of correction words `cw_list` to a CWList object,
        the extra correction word `ex_cw_dcf` to *None*, and sets the size of the key to 0.
        """
        self.s = None
        self.cw_list = CWList()
        self.ex_cw_dcf = None
        self.size = 0

    @staticmethod
    def gen(num_of_keys, alpha, beta):
        """
        Generate DCF keys.

        This method generates multiple DCF keys required for secure comparison.

        .. note::
            Distributed point function:
                f(x)=beta, if x < alpha; f(x)=0, else

        :param num_of_keys: The number of keys to generate.
        :type num_of_keys: int
        :param alpha: The comparison point (private value for comparison).
        :type alpha: RingTensor
        :param beta: The output value if the comparison is true.
        :type beta: RingTensor
        :return: A tuple containing two DCFKey objects for the two parties.
        :rtype: Tuple[DCFKey, DCFKey]

        """
        seed_0 = torch.randint(-HALF_RING, HALF_RING - 1, [num_of_keys, LAMBDA // BIT_LEN], dtype=data_type,
                               device=DEVICE)
        seed_1 = torch.randint(-HALF_RING, HALF_RING - 1, [num_of_keys, LAMBDA // BIT_LEN], dtype=data_type,
                               device=DEVICE)

        prg = PRG(PRG_TYPE, device=DEVICE)
        prg.set_seeds(seed_0)
        s_0_0 = prg.bit_random_tensor(LAMBDA)
        prg.set_seeds(seed_1)
        s_0_1 = prg.bit_random_tensor(LAMBDA)

        k0 = DCFKey()
        k1 = DCFKey()

        k0.s = s_0_0
        k1.s = s_0_1

        s_last_0 = s_0_0
        s_last_1 = s_0_1

        t_last_0 = torch.zeros(num_of_keys, 1, dtype=data_type, device=DEVICE)
        t_last_1 = torch.ones(num_of_keys, 1, dtype=data_type, device=DEVICE)

        v_a = torch.zeros((num_of_keys, 1), dtype=data_type, device=DEVICE)

        for i in range(alpha.bit_len):
            s_l_0, v_l_0, t_l_0, s_r_0, v_r_0, t_r_0 = CW.gen_dcf_cw(prg, s_last_0, LAMBDA)
            s_l_1, v_l_1, t_l_1, s_r_1, v_r_1, t_r_1 = CW.gen_dcf_cw(prg, s_last_1, LAMBDA)

            cond = (alpha.get_tensor_bit(alpha.bit_len - 1 - i) == 0).view(-1, 1)

            l_tensors = [s_l_0, s_l_1, v_l_0, v_l_1, t_l_0, t_l_1]
            r_tensors = [s_r_0, s_r_1, v_r_0, v_r_1, t_r_0, t_r_1]
            keep_tensors = [torch.where(cond, l, r) for l, r in zip(l_tensors, r_tensors)]
            lose_tensors = [torch.where(cond, r, l) for l, r in zip(l_tensors, r_tensors)]

            s_keep_0, s_keep_1, v_keep_0, v_keep_1, t_keep_0, t_keep_1 = keep_tensors
            s_lose_0, s_lose_1, v_lose_0, v_lose_1, t_lose_0, t_lose_1 = lose_tensors

            s_cw = s_lose_0 ^ s_lose_1

            v_cw = pow(-1, t_last_1) * (convert_tensor(v_lose_1) - convert_tensor(v_lose_0) - v_a)

            v_cw = torch.where(alpha.get_tensor_bit(alpha.bit_len - 1 - i) == 1, v_cw + pow(-1, t_last_1) * beta.tensor,
                               v_cw + torch.zeros_like(beta.tensor))

            v_a = (v_a
                   - convert_tensor(v_keep_1)
                   + convert_tensor(v_keep_0)
                   + pow(-1, t_last_1) * v_cw)

            t_l_cw = t_l_0 ^ t_l_1 ^ ~cond ^ 1
            t_r_cw = t_r_0 ^ t_r_1 ^ ~cond

            cw = CW(s_cw=s_cw, v_cw=v_cw, t_cw_l=t_l_cw, t_cw_r=t_r_cw, lmd=LAMBDA)

            k0.cw_list.append(cw)
            k1.cw_list.append(cw)

            t_keep_cw = torch.where(cond, t_l_cw, t_r_cw)

            s_last_0 = s_keep_0 ^ (t_last_0 * s_cw)
            s_last_1 = s_keep_1 ^ (t_last_1 * s_cw)

            t_last_0 = t_keep_0 ^ (t_last_0 * t_keep_cw)
            t_last_1 = t_keep_1 ^ (t_last_1 * t_keep_cw)

        k0.ex_cw_dcf = k1.ex_cw_dcf = pow(-1, t_last_1) * (convert_tensor(s_last_1) - convert_tensor(s_last_0) - v_a)

        return k0, k1
