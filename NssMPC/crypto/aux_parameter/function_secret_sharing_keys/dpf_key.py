"""
This document defines the DPFKey class for function secret sharing in distributed point functions (DPF)
in the context of secure multi-party computation. The keys generated by this class are used to
securely evaluate DPF between parties.
The implementation is based on the work of E. Boyle e.t.c. Function Secret Sharing: Improvements and Extensions.2016
For reference, see the `paper <https://dl.acm.org/doi/10.1145/2976749.2978429>`_.
"""

#  This file is part of the NssMPClib project.
#  Copyright (c) 2024 XDU NSS lab,
#  Licensed under the MIT license. See LICENSE in the project root for license information.

import torch

from NssMPC.common.random import PRG
from NssMPC.common.utils import convert_tensor
from NssMPC.config import HALF_RING, DEVICE, LAMBDA, BIT_LEN, data_type, PRG_TYPE
from NssMPC.crypto.aux_parameter import Parameter
from NssMPC.crypto.aux_parameter.function_secret_sharing_keys.cw import CWList, CW


class DPFKey(Parameter):
    """
    The function secret sharing key for distributed point function(DPF).

    This class implements the secret sharing keys required for function secret sharing(FSS) in
    distributed point functions (DPF). It includes methods for generating
    and managing the correction words and other key parameters used in the DPF protocol.


    ATTRIBUTES:
        * **s** (*torch.Tensor*): A binary string (Î» bits) generated by the PRG for the root node.
        * **cw_list** (:class:`CWList <NssMPC.crypto.aux_parameter.function_secret_sharing_keys.cw.CWList>`): The list of correction words used in the comparison function.
        * **ex_cw_DPF** (*torch.Tensor*): The extra check word used for DPF calculation.
        * **size** (*int*): The size of the key (default is 0).
    """

    def __init__(self):
        """
        Initialize the DPFKey object.

        This method initializes the seed `s` to **None**, the list of correction words `cw_list` to a **CWList** object,
        the extra correction word `ex_cw_DPF` to **None**, and sets the size of the key to 0.
        """
        self.s = None
        self.cw_list = CWList()
        self.ex_cw_dpf = None
        self.size = 0

    @staticmethod
    def gen(num_of_keys, alpha, beta):
        """
        Generate DPF keys.

        This method generates multiple DPF keys required for secure comparison.

        .. note::
            Distributed point function:
                f(x)=beta, if x < alpha; f(x)=0, else

        :param num_of_keys: The number of keys to generate.
        :type num_of_keys: int
        :param alpha: The comparison point (private value for comparison).
        :type alpha: RingTensor
        :param beta: The output value if the comparison is true.
        :type beta: RingTensor
        :return: A tuple containing two DPFKey objects for the two parties.
        :rtype: Tuple[DPFKey, DPFKey]

        """
        seed_0 = torch.randint(-HALF_RING, HALF_RING - 1, [num_of_keys, LAMBDA // BIT_LEN], dtype=data_type,
                               device=DEVICE)
        seed_1 = torch.randint(-HALF_RING, HALF_RING - 1, [num_of_keys, LAMBDA // BIT_LEN], dtype=data_type,
                               device=DEVICE)

        prg = PRG(PRG_TYPE, device=DEVICE)
        prg.set_seeds(seed_0)
        s_0_0 = prg.bit_random_tensor(LAMBDA)
        prg.set_seeds(seed_1)
        s_0_1 = prg.bit_random_tensor(LAMBDA)

        k0 = DPFKey()
        k1 = DPFKey()

        k0.s = s_0_0
        k1.s = s_0_1

        s_last_0 = s_0_0
        s_last_1 = s_0_1

        t_last_0 = 0
        t_last_1 = 1

        for i in range(alpha.bit_len):
            s_l_0, t_l_0, s_r_0, t_r_0 = CW.gen_dpf_cw(prg, s_last_0, LAMBDA)
            s_l_1, t_l_1, s_r_1, t_r_1 = CW.gen_dpf_cw(prg, s_last_1, LAMBDA)

            cond = (alpha.get_tensor_bit(alpha.bit_len - 1 - i) == 0).view(-1, 1)

            l_tensors = [s_l_0, s_l_1, t_l_0, t_l_1]
            r_tensors = [s_r_0, s_r_1, t_r_0, t_r_1]

            keep_tensors = [torch.where(cond, l, r) for l, r in zip(l_tensors, r_tensors)]
            lose_tensors = [torch.where(cond, r, l) for l, r in zip(l_tensors, r_tensors)]

            s_keep_0, s_keep_1, t_keep_0, t_keep_1 = keep_tensors
            s_lose_0, s_lose_1, t_lose_0, t_lose_1 = lose_tensors

            s_cw = s_lose_0 ^ s_lose_1

            t_l_cw = t_l_0 ^ t_l_1 ^ ~cond ^ 1
            t_r_cw = t_r_0 ^ t_r_1 ^ ~cond

            cw = CW(s_cw=s_cw, t_cw_l=t_l_cw, t_cw_r=t_r_cw, lmd=LAMBDA)

            k0.cw_list.append(cw)
            k1.cw_list.append(cw)

            t_keep_cw = torch.where(cond, t_l_cw, t_r_cw)

            s_last_0 = s_keep_0 ^ (t_last_0 * s_cw)
            s_last_1 = s_keep_1 ^ (t_last_1 * s_cw)

            t_last_0 = t_keep_0 ^ (t_last_0 * t_keep_cw)
            t_last_1 = t_keep_1 ^ (t_last_1 * t_keep_cw)
        k0.ex_cw_dpf = k1.ex_cw_dpf = pow(-1, t_last_1) * (
                beta.tensor
                - convert_tensor(s_last_0)
                + convert_tensor(s_last_1))

        return k0, k1
