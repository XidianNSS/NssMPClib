"""
This document defines the three classes for function secret sharing in distributed interval comparison functions (DICF)
in the context of secure multi-party computation, which respectively correspond to class DICFKey, GrottoDICFKey and SigmaDICFKey.
The keys generated by these classes are used to securely evaluate DICF between parties.

    .. note::
        Distributed interval comparison function:
            f(x)=1, if  down_bound <= x <= upper_bound; f(x)=0, else

"""

#  This file is part of the NssMPClib project.
#  Copyright (c) 2024 XDU NSS lab,
#  Licensed under the MIT license. See LICENSE in the project root for license information.

from NssMPC import RingTensor
from NssMPC.config import HALF_RING, DEVICE, BIT_LEN
from NssMPC.crypto.aux_parameter import Parameter
from NssMPC.crypto.aux_parameter.function_secret_sharing_keys.dcf_key import DCFKey
from NssMPC.crypto.aux_parameter.function_secret_sharing_keys.dpf_key import DPFKey


class DICFKey(Parameter):
    """
    The secret sharing key for distributed interval comparison function (DICF).

    This class implements the secret sharing keys required for function secret sharing (FSS) in
    distributed interval comparison functions (DICF).
    The generation of the DICF key is based on the DCF key.
    It also includes methods for generating other key parameters like r_in and z used in the DICF protocol.


    ATTRIBUTES:
        * **dcf_key** (*DCFKey*): The key of DICF.
        * **r_in** (*RingTensor*): The offset of the function, for the purpose of blind the input.
        * **z** (*RingTensor*): The parameter for offline support.
    """

    def __init__(self):
        """
        Initialize the DICFKey object.

        This method initializes the key `dcf_key` to *DCFKey* object, the offset `r_in` to *None*,
        and the parameter `z` to *None*.
        """
        self.dcf_key = DCFKey()
        self.r_in = None
        self.z = None
        self.size = 0

    @staticmethod
    def gen(num_of_keys, down_bound=RingTensor(0), upper_bound=RingTensor(HALF_RING - 1)):
        """
        Generate DICF keys.

        This method generates multiple DICF keys required for secure comparison.

        .. note::
            Distributed point function:
                f(x)=1, if  down_bound< x < upper_bound; f(x)=0, else

        :param num_of_keys: The number of keys to generate.
        :type num_of_keys: int
        :param down_bound: The down bound of the interval for DICF, default is 0.
        :type down_bound: RingTensor
        :param upper_bound: The upper bound of the interval for DICF, default is *HALF_RING-1*.
        :type upper_bound: RingTensor
        :return: A tuple containing two DICFKey objects for the two partys.
        :rtype: Tuple[DICFKey, DICFKey]
        """
        upper_bound = upper_bound.tensor
        down_bound = down_bound.tensor

        r_in = RingTensor.random([num_of_keys, 1], dtype='int')
        gamma = r_in - 1

        r_tensor = r_in.tensor
        # 修正参数
        q1 = (upper_bound + 1)
        ap = (down_bound + r_tensor)
        aq = (upper_bound + r_tensor)
        aq1 = (upper_bound + 1 + r_tensor)

        out = ((ap > aq) + 0) - ((ap > down_bound) + 0) + ((aq1 > q1) + 0) + ((aq == -1) + 0)

        k0 = DICFKey()
        k1 = DICFKey()

        keys = DCFKey.gen(num_of_keys, gamma, RingTensor(1))

        k0.dcf_key, k1.dcf_key = keys

        z_share = RingTensor.random([num_of_keys], device=DEVICE)
        r_share = RingTensor.random([num_of_keys], device=DEVICE)

        k0.z, k1.z = out.squeeze(1) - z_share, z_share
        k0.r_in, k1.r_in = r_in.squeeze(1) - r_share, r_share

        return k0, k1


class GrottoDICFKey(Parameter):
    """
    The secret sharing key for distributed interval comparison function (DICF) with the method adapted from `Grotto <https://eprint.iacr.org/2023/108>`_.

    This class implements the secret sharing keys required for function secret sharing (FSS) in
    distributed interval comparison functions (DICF).
    The generation of the GrottoDICF key is based on the DPF key.
    It also includes methods for generating other key parameters like r_in used in the GrottoDICF protocol.


    ATTRIBUTES:
        * **dpf_key** (*DPFKey*): The key of GrottoDICF.
        * **r_in** (*RingTensor*): The offset of the function, for the purpose of blind the input.
    """

    def __init__(self):
        """
        Initialize the GrottoDICFKey object.

        This method initializes the key `dpf_key` to *DPFKey* object, the offset `r_in` to *None*.
        """
        self.dpf_key = DPFKey()
        self.r_in = None

    @staticmethod
    def gen(num_of_keys, beta=RingTensor(1)):
        """
        Generate GrottoDICF keys.

        This method generates the DICF keys required for secure comparison with method adapted from Grotto.

        :param num_of_keys: The number of keys to generate.
        :type num_of_keys: int
        :param beta: The output value if the comparison is true.
        :type beta: RingTensor
        :return: A tuple containing two DICFKey objects for the two partys.
        :rtype: Tuple[GrottoDICFKey, GrottoDICFKey]
        """
        k0, k1 = GrottoDICFKey(), GrottoDICFKey()
        k0.r_in = RingTensor.random([num_of_keys])
        k1.r_in = RingTensor.random([num_of_keys])
        k0.dpf_key, k1.dpf_key = DPFKey.gen(num_of_keys, k0.r_in + k1.r_in, beta)
        return k0, k1


class SigmaDICFKey(Parameter):
    """
    The secret sharing key for distributed interval comparison function (DICF) with the method adapted from `Sigma <https://eprint.iacr.org/2023/1269>`_.

    This class implements the secret sharing keys required for function secret sharing (FSS) in
    distributed interval comparison functions (DICF).
    The generation of the SigmaDICF key is based on the DPF key.
    It also includes methods for generating other key parameters like c and r_in used in the SigmaDICF protocol.


    ATTRIBUTES:
        * **dpf_key**: The key of SigmaDICF.
        * **c**: The parameter for offline support.
        * **r_in**: The offset of the function, for the purpose of blind the input.
    """

    def __init__(self):
        """
        Initialize the SigmaDICFKey object.

        This method initializes the key `dpf_key` to *DPFKey* object, the MSB of offset `c` to *None*,
        and the offset `r_in` to *None*.
        """
        self.dpf_key = DPFKey()
        self.c = None
        self.r_in = None
        self.size = 0

    @staticmethod
    def gen(num_of_keys, bit_len=BIT_LEN):
        """
        Generate SigmaDICF keys.

        This method generates the DICF keys required for secure comparison with method adapted from Sigma.

        :param num_of_keys: The number of keys to generate.
        :type num_of_keys: int
        :param bit_len: The length of the binary bits of the offset `r_in`.
        :type bit_len: int
        :return: A tuple containing two SigmaDICFKey objects for the two parties.
        :rtype: Tuple[SigmaDICFKey, SigmaDICFKey]
        """
        k0 = SigmaDICFKey()
        k1 = SigmaDICFKey()

        k0.r_in = RingTensor.random([num_of_keys], down_bound=-2 ** (bit_len - 1), upper_bound=2 ** (bit_len - 1) - 1)
        k1.r_in = RingTensor.random([num_of_keys], down_bound=-2 ** (bit_len - 1), upper_bound=2 ** (bit_len - 1) - 1)
        r_in = k0.r_in + k1.r_in
        if bit_len < BIT_LEN:
            r_in = RingTensor.where(r_in > 2 ** (bit_len - 1) - 1, r_in - 2 ** bit_len, r_in)
            r_in = RingTensor.where(r_in < -2 ** (bit_len - 1), r_in + 2 ** bit_len, r_in)
        r_in.bit_len = bit_len

        y1 = r_in % (2 ** (bit_len - 1) - 1)
        k0.dpf_key, k1.dpf_key = DPFKey.gen(num_of_keys, y1, RingTensor(1))
        c = r_in.signbit()
        c0 = RingTensor.random([num_of_keys], down_bound=0, upper_bound=2)
        c1 = c ^ c0

        k0.c = c0
        k1.c = c1

        return k0, k1
