import math
import random

import torch

import common.random.kernel.aes as AES
import common.random.kernel.exp as TMT
import common.random.kernel.mt as MT
from common.tensor.ring_tensor import RingTensor
from config.base_configs import BIT_LEN, data_type


class PRG(object):
    """
    Seed parallel pseudo-random number generators used to generate pseudo-random numbers,
    which can be implemented using libraries such as random, PyTorch, MT, TMT, etc.
    """

    def __init__(self, kernel='random', device='cpu'):
        if kernel not in ['random', 'pytorch', 'MT', 'TMT', 'AES']:
            raise KeyError(kernel, " kernel is not supported! It should be one of the random/pytorch/MT")

        self.kernel = kernel
        self.bit_seeds = None
        self.dtype = None
        self.device = device
        self.len = None
        self.shape = None

    def set_seeds(self, seeds):
        """
        Set the seed for PRG
        The seed of this PRG is parallelized, which can simultaneously generate multiple pseudo-random numbers
        corresponding to multiple seeds.
        Here, 'seeds' is a tensor, where each element inside the tensor represents a seed.

        Args:
            seeds: each element inside the tensor represents a seed.
        """
        if isinstance(seeds, RingTensor):
            self.dtype = seeds.dtype
            self.device = seeds.device
            seeds = seeds.tensor

        self.bit_seeds = seeds.to(self.device)
        self.shape = seeds.shape
        self.len = len(self.bit_seeds)

    def bit_random_with_random_kernel(self, bits):
        """
        use the random library to generate the random number

        Generate random numbers using the built-in random library in Python,
        where the random numbers have 'bits' number of bits.
        Parallelization is achieved through looping since the random library itself doesn't support parallelization.
        The generated random numbers here are different from those generated by other methods,
        as the number of bits is directly specified.
        Therefore, they cannot be directly converted to torch.int64, but they can be used directly for FSS computations.

        Args:
            bits: the bit number of the random numbers.

        Returns:
            r: the random number generated,
               which is a list, where each element is a random number having 'bits' number of bits.

        Raise:
            ValueError: if the seed is not set, an error will be reported
        """
        if self.bit_seeds is None:
            raise ValueError("seeds is None, please set seeds first!")
        r = []
        for seed in self.bit_seeds:
            random.seed(seed)
            r.append(random.getrandbits(bits))
        return r

    def bit_random_with_pytorch_kernel(self, bits):
        """
        Use the pytorch library to generate random numbers

        Generate random numbers using the built-in random library in Pytorch,
        where the random numbers have 'bits' number of bits.
        Parallelization is achieved through looping since the random library itself doesn't support parallelization.
        Unlike the random library, the random function of the torch here can only generate 64-bit random numbers,
        and for random numbers larger than 64 bits, multiple random numbers are used to fill in the bits.

        Args:
            bits: the bit number of the random number

        Returns:
            The generated random number, which is a tensor with two dimensions.
            The first dimension represents the number of parallelization,
            and the second dimension represents the number of int64 required to generate 'bits' bit random numbers.

        Raise:
            ValueError: if the seed is not set, an error will be reported
        """
        if self.bit_seeds is None:
            raise ValueError("seeds is None, please set seeds first!")
        num = math.ceil(bits / BIT_LEN)
        r = torch.empty([self.len, num], dtype=data_type)
        for i, seed in enumerate(self.bit_seeds):
            torch.manual_seed(seed)
            r[i, :] = torch.empty([num], dtype=data_type).random_()
        r.to(self.device)
        return r

    def bit_random_with_mt_kernel(self, bits):
        """
        Use the MT library to generate random numbers

        Here, a custom implementation of the Mersenne Twister pseudo-random number generator is being invoked.
        It follows the Mersenne Twister MT19937 algorithm
        but has been enhanced with parallelization to support multiple seed parallelism.

        Args:
            bits: the bit number of random numbers

        Returns:
            The random numbers generated by the MT19937 algorithm with two dimensions.
            The first dimension represents the number of parallelization,
            and the second dimension represents the number of int64 required to generate 'bits' bit random numbers.

        Raise:
            ValueError: if the seed is not set, an error will be reported
        """
        if self.bit_seeds is None:
            raise ValueError("seeds is None, please set seeds first!")
        num = math.ceil(bits / BIT_LEN)
        MT.dev = self.device
        mt_prg = MT.TorchMT19937(self.bit_seeds)
        out = mt_prg.random(num)
        return out

    def bit_random_with_exp_kernel(self, bits):
        """
        Use the TMT library to generate random numbers

        Here, a custom simplified version of the Mersenne Twister pseudo-random number generator is being invoked.

        Args:
            bits: the bit number of random numbers

        Returns:
            The random numbers generated by the MT19937 algorithm with two dimensions.
            The first dimension represents the number of parallelization,
            and the second dimension represents the number of int64 required to generate 'bits' bit random numbers.

        Raise:
            ValueError: if the seed is not set, an error will be reported
        """

        if self.bit_seeds is None:
            raise ValueError("seeds is None, please set seeds first!")

        num = math.ceil(bits / BIT_LEN)
        tmt_prg = TMT.TMT(self.bit_seeds)
        out = tmt_prg.random(num)
        return out

    def bit_random_with_aes_kernel(self, bits):
        """
        Use pytorch/csprng library to generate random numbers automatically

        Args:
            bits: the bit number of random numbers
        """
        if self.bit_seeds is None:
            raise ValueError("seeds is None, please set seeds first!")
        aes_prg = AES.AES(self.bit_seeds)
        out = aes_prg.bit_random(bits)
        return out

    def _bit_random(self, n_bits):
        """
        The api to generate random numbers of n bits.

        Args:
            n_bits: the bit number of random numbers

        Returns:
            The random numbers generated.
            For random library, it's a list.
            For others, it's a tensor with two dimensions.
            The first dimension represents the number of parallelization.
            And the second dimension represents the number of int64 required to generate 'bits' bit random.
        """
        if self.kernel == 'random':
            gen = self.bit_random_with_random_kernel(n_bits)
        elif self.kernel == 'pytorch':
            gen = self.bit_random_with_pytorch_kernel(n_bits)
        elif self.kernel == 'MT':
            gen = self.bit_random_with_mt_kernel(n_bits)
        elif self.kernel == 'TMT':
            self.set_seeds(self.bit_seeds.view(-1, 2)[:, 0].view(-1))
            gen = self.bit_random_with_exp_kernel(n_bits)
        elif self.kernel == 'AES':
            gen = self.bit_random_with_aes_kernel(n_bits)
        else:
            gen = self.bit_random_with_pytorch_kernel(n_bits)
        return gen

    def bit_random(self, bits, dtype=None, device=None):
        """
        Create a RingTensor containing n-bit random numbers that can be generated in parallel,
        with the number of parallel operations matching the number of seed values.

        Args:
            bits: the bit number of random numbers
            dtype
            device

        Returns:
            A RingTensor, which is a random number with n bits
        """
        if dtype is None:
            dtype = self.dtype
        if device is None:
            device = self.device
        gen = self._bit_random(bits)
        return RingTensor(gen, dtype, device)
