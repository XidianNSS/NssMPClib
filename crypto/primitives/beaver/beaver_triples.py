import os
import random
import re

from common.aux_parameter.parameter import Parameter
from common.tensor import *
from config.base_configs import base_path
from crypto.primitives.homomorphic_encryption.paillier import Paillier


class BeaverTriples(Parameter):
    def __init__(self):
        self.a = None
        self.b = None
        self.c = None
        self.size = 0
        self.share_type = "22"

    def __iter__(self):
        return iter((self.a, self.b, self.c))

    def set_party(self, party):
        self.a.party = party
        self.b.party = party
        self.c.party = party

    def set_triples(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def gen(num_of_triples, num_of_party=2, type_of_generation='TTP', party=None):
        """
        Generate multiplicative Beaver triples

        Args:
            num_of_triples: the number of triples
            num_of_party: the number of parties
            type_of_generation: generation type,
                                TTP: generated by trusted third party,
                                HE: generated by homomorphic encryption,
            party: x_shape if MAT or party if HE \n
        """
        if num_of_party == 2:
            if type_of_generation == 'HE':
                return gen_triples_by_homomorphic_encryption(num_of_triples, party)
            elif type_of_generation == 'TTP':
                return gen_triples_by_ttp(num_of_triples)

    @classmethod
    def gen_and_save(cls, num_of_triples, num_of_party=2, type_of_generation='TTP', party=None):
        """
        Generate and save multiplicative Beaver triples

        Args:
            num_of_triples: the number of triples
            num_of_party: the number of parties
            type_of_generation: generation type,
                                TTP: generated by trusted third party,
                                HE: generated by homomorphic encryption,
            party: party if HE \n
        """
        triples = cls.gen(num_of_triples, num_of_party, type_of_generation, party)
        if type_of_generation == 'TTP':
            for party_id in range(num_of_party):
                Parameter.save(triples[party_id], party_id, num_of_party)
        elif type_of_generation == 'HE':
            file_path = f"{base_path}/aux_parameters/BeaverTriples/{num_of_party}party/"
            if not os.path.exists(file_path):
                os.makedirs(file_path)

            file_names = os.listdir(file_path)
            max_ptr = 0
            for fname in file_names:
                match = re.search(rf"BeaverTriples_{party.party_id}+_(\d+)\.pth", fname)
                if match:
                    max_ptr = max(max_ptr, int(match.group(1)))
            file_name = f"BeaverTriples_{party.party_id}_{max_ptr + 1}.pth"
            triples.save_by_name(file_name, file_path)


def gen_triples_by_ttp(num_of_triples):
    """
    Generate the multiplication Beaver triple by trusted third party

    Args:
        num_of_triples: the number of triples

    Returns:
        the multiplication triple
    """

    a = RingFunc.random([num_of_triples])
    b = RingFunc.random([num_of_triples])
    c = a * b

    from crypto.primitives.arithmetic_secret_sharing.arithmetic_shared_ring_tensor import ArithmeticSharedRingTensor
    a_list = ArithmeticSharedRingTensor.share(a, 2)
    b_list = ArithmeticSharedRingTensor.share(b, 2)
    c_list = ArithmeticSharedRingTensor.share(c, 2)

    triples = []
    for i in range(2):
        triples.append(BeaverTriples())
        triples[i].share_type = "22"
        triples[i].a = a_list[i].to('cpu')
        triples[i].b = b_list[i].to('cpu')
        triples[i].c = c_list[i].to('cpu')
        triples[i].size = num_of_triples

    return triples


def gen_triples_by_homomorphic_encryption(num_of_triples, party):
    """
    Generate the multiplication Beaver triple by homomorphic encryption

    Args:
        num_of_triples: the number of triples
        party: the party to get triples

    Returns:
        the multiplication triple
    """
    a = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
    b = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
    c = []

    if party.party_id == 0:
        paillier = Paillier()
        paillier.gen_keys()

        encrypted_a = paillier.encrypt(a)
        encrypted_b = paillier.encrypt(b)

        party.send([encrypted_a, encrypted_b, paillier.public_key])

        d = party.receive()
        decrypted_d = paillier.decrypt(d)
        c = [decrypted_d[i] + a[i] * b[i] for i in range(num_of_triples)]

    elif party.party_id == 1:

        r = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
        c = [a[i] * b[i] - r[i] for i in range(num_of_triples)]

        messages = party.receive()

        encrypted_r = Paillier.encrypt_with_key(r, messages[2])
        d = [messages[0][i] ** b[i] * messages[1][i] ** a[i] * encrypted_r[i] for i in range(num_of_triples)]

        party.send(d)

    triples = BeaverTriples()
    from crypto.primitives.arithmetic_secret_sharing.arithmetic_shared_ring_tensor import ArithmeticSharedRingTensor
    triples.a = ArithmeticSharedRingTensor(RingTensor(a).to('cpu'), party)
    triples.b = ArithmeticSharedRingTensor(RingTensor(b).to('cpu'), party)
    triples.c = ArithmeticSharedRingTensor(RingTensor(c).to('cpu'), party)
    triples.size = num_of_triples

    return triples
